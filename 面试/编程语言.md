### C++
**定义一个空的类，里面每个任何成员变量和成员函数，对该类型求sizeof，得到的结果是多少？**
- 答案是1，空类的实例中不包含任何信息，本来求sizeof应该是0，但是当我们声明该类型的实例的时候，它必须在内存中占有一定的空间，否则无法使用这些实例。至于占用多少内存，由编译器决定。

**如果在该类型中添加一个构造函数和析构函数，再对该类型求sizeof，得到的结果是多少？**
- 答案是1，调用构造函数和析构函数只需要知道函数的地址即可，而这些函数的地址只与类型相关，而与类型的实例无关。

**C++二义性**
在C++中会导致二义性错误的有两种情况：
第一种：类里面定义了两个以上的重载函数，但是其中一个重载的函数有默认值，例如：
```
class Son 
{
    public :
        void print();
        void print(int i=10);
    private :
    protected :
};
```
这个时候调用print函数将引发二义性错误。

第二种错误：
子类继承了多个父类，多个父类中有相同的函数，倒三角形和菱形。
倒三角形解决方案: 区域限定符（::）例如: obj.Class::func()
菱形解决方案: 例如有基类B，从B派生出C和D，然后类F又同时继承了C和D，现在类F的一个对象里面包含了两个基类B的对象，如果F访问自己的从基类B那里继承过来的的数据成员或者函数成员那么编译器就不知道你指的到底是从C那里继承过来的B对象呢还是从D那里继承过来的B对象。 于是虚基类诞生了，将C和D的继承方式改为虚继承，那么F访问自己从B那里继承过来的成员就不会有二义性问题了，也就是将F对象里的B对象统一为一个，只有一个基类B对象。


**如果把析构函数标记为虚拟函数呢？**
- C++编译器一旦发现一个类型中有虚函数，就会为该类型生成虚函数表，并在该类型的每个实例中添加一个指向虚函数表的指针，32位机器中，一个指针占用4个字节的空间，64位机器中，一个指针占用8个字节的空间。

**数组**
- 由于数组中的内存是连续的，于是可以根据下标在O(1)时间读/写任何元素，因此它的时间效率是很高的，我们可以根据数组时间效率高的优点，用数组来实现简单的哈希表：把数组的下标设为哈希表的(Key)，而数组中每个元素设置为哈希表的值(Value)，这样每个下标及数组中的该下标对应的数字就组成了一个键值-值的匹配。
- 为了解决数组空间效率不高的问题，人们又设计实现了多种动态数组，比如C++的STL中的vector，为了避免浪费，我们先为数组开辟较小的空间，然后往数组中添加数组，当数据的数目超过数组的容量时，我们在重新分配一块更大的空间(STL的vector每次扩充容量时，新的容量都是前一次的两倍)，把之前的数据复制到新的数组中，再把之前的内存释放，这样就可以减少内存的浪费。但是每次扩充容量时都有大量的额外操作，因此使用动态数组时要尽量减少改变数组容量大小的次数。
- C/C++没有记录数组的大小，因此用指针访问数组中的元素时，程序员要确保没有超过数组的边界。
- 当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针。

**字符串**
- C/C++中每个字符串都以字符'\0'作为结尾，这样我们就能方便地找到字符串的最后末尾。每个字符串中都有一个额外字符的开销。
- 为了节省内存，C/C++把常量字符串放到一个单独的内存区域，当几个指针赋值给相同的常量字符串时，它们实际上会指向相同的内存地址。但用常量内存初始化数组，情况却有所不同。