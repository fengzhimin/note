**一个有序数组只有一个数不出现两次，找出这个数**
- 采用二分查找的方法进行查找，确保查找区间大小一直都是基数。

**序列中只有一个数出现了一次，其他均出现了两次，找出只出现过一次的这个数**
- 位操作符: ^ 相同的结果会得到全0；和全0异或，结果不变；和全1异或，结果会得到自己的取反。
- 对所有的数进行异或操作，结果就是只出现过一次的数。

**一个数组中只有两个数字是出现一次，其他所有数字都出现了两次，找出这两个数字**
- 将0与数组每个元素依次异或的结果就是两个只出现一次的元素异或的值。
- 将数组分为两组，每一组包含一个只出现一次的数，分组的思路是：两个唯一的数是不相同的，那么在他们的二进制序列中必然有一位是不相同的，取出异或后最低位的1当作flag，用flag异或数组里的每一个数可以将数分成两组。
- 将两个数组分别与0进行亦或，最终得到两个只出现一次的数。

**有10001个整数，这些数是1-10000，其中只有一个数出现两次，找出这个数**
- 用这10001个数的和减去1-10000的和，结果就是出现两次的数。

**分隔字符串使同种字符出现在一起** 

```
int main()
{
	string str;
	cin >> str;
	int *lastIndexs = new int[26];
	list<int> ret;

	for(int i = 0; i < str.length(); i++)
		lastIndexs[str[i]-'a'] = i;

	int firstIndex = 0;
	while(firstIndex < str.length())
	{
		int lastIndex = firstIndex;
		for(int i = firstIndex; i < str.length() && i <= lastIndex; i++)
		{
			int index = lastIndexs[str[i]-'a'];
			if(index == i) continue;
			if(index > lastIndex) lastIndex = index;
		}

		ret.push_back(lastIndex - firstIndex + 1);
		firstIndex = lastIndex + 1;
	}

	for(list<int>::iterator iter = ret.begin(); iter != ret.end(); iter++)
		cout << *iter << " ";

	cout << endl;

	return 0;
}
```

**从一个已经排序的数组中找出两个数，使它们的和为0**
- 使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum > target，移动较大的元素，使 sum 变小一些；如果 sum < target，移动较小的元素，使 sum 变大一些。

**将单链表反转**
- 从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。

```
ListNode * ReverseList(ListNode * pHead)
{
	if(pHead == NULL || pHead->next == NULL)
    	return pHead;
    
    ListNode * pReverseHead = NULL; //反转后的新链表头指针，初始化为NULL
    ListNode * pCurrent = pHead;
    while(pCurrent != NULL)
    {
    	ListNode *pTemp = pCurrent;
        pCurrent = pCurrent->next;
        pTemp->next = pReverseHead;  //将当前节点摘下，插入新链表的最前端
        pReverseHead = pTemp;
    }
    
    return pReverseHead;
}
```

**查找单链表中的倒数第K个结点（k > 0）**
- 最普遍的方法是，先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n）。
- 另一种思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。

**查找单链表的中间结点**
- 此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）。

**从尾到头打印单链表**
- 对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。

**判断一个单链表中是否有环**
- 这里也是用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n）。

**判断两个单链表是否相交**
- 如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1)。

**求两个单链表相交的第一个节点**
- 对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。
- 对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。
- 两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。

**已知一个单链表中存在环，求进入环中的第一个节点**
- 首先判断是否存在环，若不存在结束。在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。

**给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted**
- 对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)。