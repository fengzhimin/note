**一个有序数组只有一个数不出现两次，找出这个数**
- 采用二分查找的方法进行查找，确保查找区间大小一直都是基数。

**序列中只有一个数出现了一次，其他均出现了两次，找出只出现过一次的这个数**
- 位操作符: ^ 相同的结果会得到全0；和全0异或，结果不变；和全1异或，结果会得到自己的取反。
- 对所有的数进行异或操作，结果就是只出现过一次的数。

**一个数组中只有两个数字是出现一次，其他所有数字都出现了两次，找出这两个数字**
- 将0与数组每个元素依次异或的结果就是两个只出现一次的元素异或的值。
- 将数组分为两组，每一组包含一个只出现一次的数，分组的思路是：两个唯一的数是不相同的，那么在他们的二进制序列中必然有一位是不相同的，取出异或后最低位的1当作flag，用flag异或数组里的每一个数可以将数分成两组。
- 将两个数组分别与0进行亦或，最终得到两个只出现一次的数。

**有10001个整数，这些数是1-10000，其中只有一个数出现两次，找出这个数**
- 用这10001个数的和减去1-10000的和，结果就是出现两次的数。

**分隔字符串使同种字符出现在一起** 

```
int main()
{
	string str;
	cin >> str;
	int *lastIndexs = new int[26];
	list<int> ret;

	for(int i = 0; i < str.length(); i++)
		lastIndexs[str[i]-'a'] = i;

	int firstIndex = 0;
	while(firstIndex < str.length())
	{
		int lastIndex = firstIndex;
		for(int i = firstIndex; i < str.length() && i <= lastIndex; i++)
		{
			int index = lastIndexs[str[i]-'a'];
			if(index == i) continue;
			if(index > lastIndex) lastIndex = index;
		}

		ret.push_back(lastIndex - firstIndex + 1);
		firstIndex = lastIndex + 1;
	}

	for(list<int>::iterator iter = ret.begin(); iter != ret.end(); iter++)
		cout << *iter << " ";

	cout << endl;

	return 0;
}
```

**从一个已经排序的数组中找出两个数，使它们的和为0**
- 使用双指针，一个指针指向元素较小的值，一个指针指向元素较大的值。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。
- 如果两个指针指向元素的和 sum == target，那么得到要求的结果；如果 sum > target，移动较大的元素，使 sum 变小一些；如果 sum < target，移动较小的元素，使 sum 变大一些。

**只用2GB内存在20亿个整数（32位）中找到出现次数最多的数**
- 想要在很多整数中找到出现次数最多的数，通常的做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某一个整数，value是这个数出现的次数。就本题来说，一共有20亿个数，哪怕只是一个数出现了20亿次，用32位的整数也可以表示其出现的次数而不会溢出，所以哈希表的key占用4B，value占用4B，因此一条记录占用8B，在极端情况下，有20亿条记录，需要20亿*8B=16GB>2GB。
- 解决办法是把包含20亿个数的大文件用哈希函数分成16个小文件，根据哈西函数的性质，用一种数不可能被哈希到不同的小文件上。然后对每一个小文件中用哈希表来统计其中每种数出现的次数没这样我们就得到了16个小文件中各自出现次数最多的数，还有各自的次数统计。接下来只要选出这16个小文件各自的第一名中最大的数即可。

**海量日志数据，提取出某日访问百度次数最多的那个IP**
- 算法思想：分而治之+Hash
	* 1、IP地址最多有2^32=4G种取值情况，所以不能完全加载到内存中处理；
	* 2、可以考虑采用分而治之的思想，按照IP地址的Hash(IP) % 1024值，把海量IP日志分别存储到1024个小文件中，这样，每个小文件最多包含4MB个IP地址；
		* 这里解释一下为什么用Hash(IP) % 1024值，如果不用，而直接分类的话，可能会出现这样一种情况，就是有个IP在每个小文件中都存在，而且这个IP并不一定在那个小文件中是数量最多的，那么最终可能选择的结果会有问题，所以这里用了Hash(IP)%1024值，这样的话，通过计算IP的Hash值，相同IP肯定会放到一个文件中，当然了不同的IP的Hash值也可能相同，就存在一个小文件中。
	* 3、对于每一个小文件，可以构建一个IP为key，出现的次数为value的Hash Map，同时记录当前出现次数最多的那个IP地址；
	* 4、可以得到1024个小文件中的出现次数最多的那个IP，再依据常规的排序算法得出总体上出现次数最多的IP。

**旋转数组中的最小数字**
- 旋转数组的特点：
（1）递增排序的数组旋转之后的数组可划分为两个排序的子数组；
（2）前面的子数组的元素都大于或等于后面子数组的元素；
（3）最小的元素刚好是两个子数组的分界线；
（4）旋转数组在一定程度上是有序的；
在有序的数组中可以用二分查找实现O(logn)的查找，我们也可用二分查找的思想寻找旋转数组的最小数字。

- 思路：
1. 设置两个指针，初始状态第一个指针指向前面子数组的第一个元素，第二个指针指向后面子数组的最后一个元素；
2. 找到两个指针的中间元素；
3.若其大于等于第一个指针指向的元素，则说明其在前面的子数组中，且显然最小元素在中间元素的右边，若其小于等于第二个指针指向的元素，则说明其在后面的子数组中，且显然最小元素在中间元素的左边。

**将单链表反转**
- 从头到尾遍历原链表，每遍历一个结点，将其摘下放在新链表的最前端。注意链表为空和只有一个结点的情况。时间复杂度为O（n）。

```
ListNode * ReverseList(ListNode * pHead)
{
	if(pHead == NULL || pHead->next == NULL)
    	return pHead;
    
    ListNode * pReverseHead = NULL; //反转后的新链表头指针，初始化为NULL
    ListNode * pCurrent = pHead;
    while(pCurrent != NULL)
    {
    	ListNode *pTemp = pCurrent;
        pCurrent = pCurrent->next;
        pTemp->next = pReverseHead;  //将当前节点摘下，插入新链表的最前端
        pReverseHead = pTemp;
    }
    
    return pReverseHead;
}
```

**查找单链表中的倒数第K个结点（k > 0）**
- 最普遍的方法是，先统计单链表中结点的个数，然后再找到第（n-k）个结点。注意链表为空，k为0，k为1，k大于链表中节点个数时的情况。时间复杂度为O（n）。
- 另一种思路就是使用两个指针，先让前面的指针走到正向第k个结点，这样前后两个指针的距离差是k-1，之后前后两个指针一起向前走，前面的指针走到最后一个结点时，后面指针所指结点就是倒数第k个结点。

**查找单链表的中间结点**
- 此题可应用于上一题类似的思想。也是设置两个指针，只不过这里是，两个指针同时向前走，前面的指针每次走两步，后面的指针每次走一步，前面的指针走到最后一个结点时，后面的指针所指结点就是中间结点，即第（n/2+1）个结点。注意链表为空，链表结点个数为1和2的情况。时间复杂度O（n）。

**从尾到头打印单链表**
- 对于这种颠倒顺序的问题，我们应该就会想到栈，后进先出。所以，这一题要么自己使用栈，要么让系统使用栈，也就是递归。注意链表为空的情况。时间复杂度为O（n）。

**判断一个单链表中是否有环**
- 这里也是用到两个指针。如果一个链表中有环，也就是说用一个指针去遍历，是永远走不到头的。因此，我们可以用两个指针去遍历，一个指针一次走两步，一个指针一次走一步，如果有环，两个指针肯定会在环中相遇。时间复杂度为O（n）。

**判断两个单链表是否相交**
- 如果两个链表相交于某一节点，那么在这个相交节点之后的所有节点都是两个链表所共有的。也就是说，如果两个链表相交，那么最后一个节点肯定是共有的。先遍历第一个链表，记住最后一个节点，然后遍历第二个链表，到最后一个节点时和第一个链表的最后一个节点做比较，如果相同，则相交，否则不相交。时间复杂度为O(len1+len2)，因为只需要一个额外指针保存最后一个节点地址，空间复杂度为O(1)。

**求两个单链表相交的第一个节点**
- 对第一个链表遍历，计算长度len1，同时保存最后一个节点的地址。
- 对第二个链表遍历，计算长度len2，同时检查最后一个节点是否和第一个链表的最后一个节点相同，若不相同，不相交，结束。
- 两个链表均从头节点开始，假设len1大于len2，那么将第一个链表先遍历len1-len2个节点，此时两个链表当前节点到第一个相交节点的距离就相等了，然后一起向后遍历，知道两个节点的地址相同。

**已知一个单链表中存在环，求进入环中的第一个节点**
- 首先判断是否存在环，若不存在结束。在环中的一个节点处断开（当然函数结束时不能破坏原链表），这样就形成了两个相交的单链表，求进入环中的第一个节点也就转换成了求两个单链表相交的第一个节点。

**给出一单链表头指针pHead和一节点指针pToBeDeleted，O(1)时间复杂度删除节点pToBeDeleted**
- 对于删除节点，我们普通的思路就是让该节点的前一个节点指向该节点的下一个节点，这种情况需要遍历找到该节点的前一个节点，时间复杂度为O(n)。对于链表，链表中的每个节点结构都是一样的，所以我们可以把该节点的下一个节点的数据复制到该节点，然后删除下一个节点即可。要注意最后一个节点的情况，这个时候只能用常见的方法来操作，先找到前一个节点，但总体的平均时间复杂度还是O(1)。

**有n级台阶，一个人每次上一级或者两级，问有多少种走完n级台阶的方法**
- 递归方法求解(时间复杂度为2的n次方)
```
int getResult(int n)
{
	if(n < 1)
    	return 0;
    if(n == 1)
    	return 1;
    if(n == 2)
    	return 2;
    return getResult(n-1) + getResult(n - 2);
}
```

**二进制中1的个数**
```
防止负数出现
int NumberOf1(int n)
{
    int count = 0;
    unsigned int flag = 1;
    while(flag){
        if(n & flag){
            count++;
        }
        flag = flag << 1;
    }
    return count;
}
int NumberOf1(int n)
{
    int count = 0;
    while(n){
        count++;  //只要n不为0则其至少有一个1
        n = n & (n - 1);
    }
    return count;
}
```

**判断一个数是否为2的n次方**
- n & (n - 1) == 1 不是，否则是。

- 动态规划(时间复杂度为O(n)，空间复杂度为O(1))
```
int getResult(int n)
{
	if(n < 1)
    	return 0;
    if(n == 1)
    	return 1;
    if(n == 2)
    	return 2;
    
    int a = 1, b = 2, temp = 0;
    for(int i = 0; i < n + 1; i++)
    {
    	temp = a + b;
        a = b;
        b = temp;
    }
    return temp;
}
```

