[TOC]
### 文件和文件系统
#### 普通文件
- 	> 文件的大小通过字节来计算，称为文件长度。文件长度，就是组成文件的线性数组里字节的数目。文件的长度可以通过截断(truncation)来改变。
	>> - 文件可以通过删除文件结尾部分而截短为稍小的文件。
	>> - 文件可以被截断成比原来更大的文件，在这种情况下，文件以**0**进行填充(在文件的末尾)。

	> 文件通过文件名进行访问，对于文件本身并不与文件名称直接关联，相反，文件通过inode(信息节点)来访问。
	>> - 一个inode存储文件关联的元数据，如修改时间戳、所有者、类型、长度以及文件的数据的地址，但是没有文件名。

#### 目录和链接
- > 目录将易读的名字和iNode编号进行隐射，名字与inode的配对，称为链接(link)。
- > 将不同名字隐射到同一个inode信息节点的多个链接称为硬链接。

### 进程和线程
- 使用errno时常犯的错误是忘记库函数和系统调用都可以修改errno，如果你需要跨函数来保留errno的值，则需要提前将errno的值保存。
- 在单线程程序中，errno是全局变量。然而，在多线程程序中，每一个程序都保留了自己的errno，因此是线程安全的。

### 文件IO
- > 每个进程按照惯例会至少有三个打开的文件描述符：0,1和2，除非进程显式的关闭它们。
  >> - 0:标准输入(stdin)
  >> - 1:标准输出(stdout)
  >> - 2:标准错误(stderr)
- Linux中使用open新创建的文件的权限(mode)操作时要与umask取反进行与操作后得到的权限才是真正的文件权限。

#### read()读取文件

```
#include <unistd.h>

ssize_t read(int fd, void *buf, size_t len);
```
- > 返回值
  >> 返回一个比len小的非零正整数是正确的，出现这种情况的原因为：
  >>> 1. 可供读取的字节数本来就比len少。
  >>> 2. 系统调用可能被信号打断。
  >>> 3. 管道可能被破坏(如果fd是个管道)等等。

  >> 返回值是0的时候：
  >>> 读取到文件尾，如果一个调用需要读len个字符，但却没有一个字符可读，调用将阻塞(睡眠)，知道有字符可以被读取为止，这与返回EOF是不同的。

  >> 调用阻塞，因为没有可用数据被读取，只会发生在阻塞情况下。
  >> 调用返回-1
  >>> errno = EINTR 表示在读入数据之前收到一个信号，可以重写调用
  >>> errno = EAGAIN 表示读取是因为没有可用的数据而阻塞，这种非阻塞模式下发生
  >>> errno = 其他 表示读取时发生其他的致命错误

